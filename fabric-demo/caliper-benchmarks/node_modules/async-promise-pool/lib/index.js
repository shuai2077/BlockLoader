"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see: http://bluebirdjs.com/docs/api/deferred-migration.html
function defer() {
  var resolve = function resolve() {};
  var reject = function reject() {};
  var promise = new _promise2.default(function (res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    resolve: resolve,
    reject: reject,
    promise: promise
  };
}

var PromisePool = function () {
  function PromisePool() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PromisePool);
    this.queue = [];
    this.pool = [];
    this.results = [];
    this.concurrency = Number.MAX_VALUE;
    this.next = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var promiseProducer, result, promise;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!_this.error) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", _this.final.reject(_this.error));

            case 2:
              if (!(!_this.queue.length && !_this.pool.length)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", _this.final.resolve(_this.results));

            case 4:
              if (!(_this.pool.length >= _this.concurrency || !_this.queue.length)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return");

            case 6:

              // At this point we have a new promise to run and the concurrency to run it
              promiseProducer = _this.queue.shift();
              result = void 0;
              promise = void 0;
              _context.prev = 9;

              promise = promiseProducer();
              _this.pool.push(promise);
              _context.next = 14;
              return promise;

            case 14:
              result = _context.sent;


              _this.results.push(result);
              _this.pool = _this.pool.filter(function (p) {
                return p !== promise;
              });
              _context.next = 22;
              break;

            case 19:
              _context.prev = 19;
              _context.t0 = _context["catch"](9);

              _this.error = _context.t0;

            case 22:
              return _context.abrupt("return", _this.next());

            case 23:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, _this, [[9, 19]]);
    }));

    if (options.concurrency) {
      this.concurrency = options.concurrency;
    }
    this.final = defer();
  }

  (0, _createClass3.default)(PromisePool, [{
    key: "add",
    value: function add(promiseProducer) {
      this.queue.push(promiseProducer);
      this.next();
    }
  }, {
    key: "all",
    value: function all() {
      if (!this.pool.length && !this.queue.length) return [];
      return this.final.promise;
    }
  }]);
  return PromisePool;
}();

module.exports = PromisePool;